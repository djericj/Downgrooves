export interface ITunesTrack {
  artistId: string;
  artistName: string;
  artworkUrl100: string;
  collectionId: string;
  collectionArtistName: string;
  collectionName: string;
  collectionPrice: string;
  collectionViewUrl: string;
  discCount: string;
  discNumber: string;
  previewUrl: string;
  releaseDate: string;
  trackId: string;
  trackName: string;
  trackNumber: string;
  trackPrice: string;
  trackTimeMillis: string;
  trackViewUrl: string;
  wrapperType: string;
  kind: string;
}

export interface ITunesCollection {
  artistId: string;
  artistName: string;
  artworkUrl100: string;
  collectionId: string;
  collectionName: string;
  collectionPrice: string;
  collectionViewUrl: string;
  copyright: string;
  previewUrl: string;
  releaseDate: string;
  trackCount: string;
  wrapperType: string;
}

export interface ITunesLookupResult {
  resultCount: number;
  results: ITunesTrack[];
}

// Generated by https://quicktype.io

export interface IMix {
  MixId: string;
  Name: string;
  artist: Artist;
  ShortDescription: string;
  Mp3File: string;
  attachment: string;
  CreateDate: string;
  GenreId: string;
  TotalPlays: string;
  LastPlay: string;
  Tracks: Track[] | Track;
}

export interface Track {
  TrackId: string;
  MixId: string;
  Number: string;
  artist: string;
  title: string;
  Remix?: string;
  label?: string;
}

export enum Artist {
  EricJ = "Eric J",
  Mario = "Mario",
  MarioEricJ = "Mario & Eric J"
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export namespace Convert {
  export function toIMix(json: string): IMix[] {
    return cast(JSON.parse(json), a(r("IMix")));
  }

  export function iMixToJson(value: IMix[]): string {
    return JSON.stringify(value, null, 2);
  }

  function cast<T>(obj: any, typ: any): T {
    if (!isValid(typ, obj)) {
      throw Error(`Invalid value`);
    }
    return obj;
  }

  function isValid(typ: any, val: any): boolean {
    if (typ === "any") {
      return true;
    }
    if (typ === null) {
      return val === null;
    }
    if (typ === false) {
      return false;
    }
    while (typeof typ === "object" && typ.ref !== undefined) {
      typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) {
      return isValidEnum(typ, val);
    }
    if (typeof typ === "object") {
      return typ.hasOwnProperty("unionMembers")
        ? isValidUnion(typ.unionMembers, val)
        : typ.hasOwnProperty("arrayItems")
          ? isValidArray(typ.arrayItems, val)
          : typ.hasOwnProperty("props")
            ? isValidObject(typ.props, typ.additional, val)
            : false;
    }
    return isValidPrimitive(typ, val);
  }

  function isValidPrimitive(typ: string, val: any) {
    return typeof typ === typeof val;
  }

  function isValidUnion(typs: any[], val: any): boolean {
    // val must validate against one typ in typs
    return typs.some(typ => isValid(typ, val));
  }

  function isValidEnum(cases: string[], val: any): boolean {
    return cases.indexOf(val) !== -1;
  }

  function isValidArray(typ: any, val: any): boolean {
    // val must be an array with no invalid elements
    return (
      Array.isArray(val) &&
      val.every(element => {
        return isValid(typ, element);
      })
    );
  }

  function isValidObject(
    props: { [k: string]: any },
    additional: any,
    val: any
  ): boolean {
    if (val === null || typeof val !== "object" || Array.isArray(val)) {
      return false;
    }
    return Object.getOwnPropertyNames(val).every(key => {
      const prop = val[key];
      if (Object.prototype.hasOwnProperty.call(props, key)) {
        return isValid(props[key], prop);
      }
      return isValid(additional, prop);
    });
  }

  function a(typ: any) {
    return { arrayItems: typ };
  }

  function u(...typs: any[]) {
    return { unionMembers: typs };
  }

  function o(props: { [k: string]: any }, additional: any) {
    return { props, additional };
  }

  function m(additional: any) {
    return { props: {}, additional };
  }

  function r(name: string) {
    return { ref: name };
  }

  const typeMap: any = {
    IMix: o(
      {
        MixId: "",
        Name: "",
        artist: r("Artist"),
        ShortDescription: "",
        Mp3File: "",
        attachment: "",
        CreateDate: "",
        GenreId: "",
        TotalPlays: "",
        LastPlay: "",
        Tracks: u(a(r("Track")), r("Track"))
      },
      false
    ),
    Track: o(
      {
        TrackId: "",
        MixId: "",
        Number: "",
        artist: "",
        title: "",
        Remix: u(undefined, ""),
        label: u(undefined, "")
      },
      false
    ),
    Artist: ["Eric J", "Mario", "Mario & Eric J"]
  };
}
